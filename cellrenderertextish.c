/* cellrenderertextish.c generated by valac 0.56.3, the Vala compiler
 * generated from cellrenderertextish.vala, do not modify */

/* compile with  valac -c cellrenderertextish.vala --pkg gtk+-3.0 -C -H cellrenderertextish.h */

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"

#include "cellrenderertextish.h"
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>
#include <glib/gi18n-lib.h>
#include <cairo-gobject.h>
#include <float.h>
#include <math.h>

enum  {
	CELL_RENDERER_TEXTISH_0_PROPERTY,
	CELL_RENDERER_TEXTISH_NUM_PROPERTIES
};
static GParamSpec* cell_renderer_textish_properties[CELL_RENDERER_TEXTISH_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_CELL_EDITABLE_ACCEL (cell_editable_accel_get_type ())
#define CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel))
#define CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))
#define IS_CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_ACCEL))
#define IS_CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_ACCEL))
#define CELL_EDITABLE_ACCEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))

typedef struct _CellEditableAccel CellEditableAccel;
typedef struct _CellEditableAccelClass CellEditableAccelClass;

#define TYPE_CELL_EDITABLE_COMBO (cell_editable_combo_get_type ())
#define CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableCombo))
#define CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))
#define IS_CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_COMBO))
#define IS_CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_COMBO))
#define CELL_EDITABLE_COMBO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))

typedef struct _CellEditableCombo CellEditableCombo;
typedef struct _CellEditableComboClass CellEditableComboClass;

#define TYPE_CELL_EDITABLE_DUMMY (cell_editable_dummy_get_type ())
#define CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy))
#define CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))
#define IS_CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_DUMMY))
#define IS_CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_DUMMY))
#define CELL_EDITABLE_DUMMY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))

typedef struct _CellEditableDummy CellEditableDummy;
typedef struct _CellEditableDummyClass CellEditableDummyClass;
enum  {
	CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_NUM_SIGNALS
};
static guint cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_NUM_SIGNALS] = {0};
typedef struct _CellEditableDummyPrivate CellEditableDummyPrivate;
enum  {
	CELL_EDITABLE_DUMMY_0_PROPERTY,
	CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_DUMMY_NUM_PROPERTIES
};
static GParamSpec* cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_NUM_PROPERTIES];
typedef struct _CellEditableAccelPrivate CellEditableAccelPrivate;
enum  {
	CELL_EDITABLE_ACCEL_0_PROPERTY,
	CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_ACCEL_NUM_PROPERTIES
};
static GParamSpec* cell_editable_accel_properties[CELL_EDITABLE_ACCEL_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
typedef struct _CellEditableComboPrivate CellEditableComboPrivate;
enum  {
	CELL_EDITABLE_COMBO_0_PROPERTY,
	CELL_EDITABLE_COMBO_NUM_PROPERTIES
};
static GParamSpec* cell_editable_combo_properties[CELL_EDITABLE_COMBO_NUM_PROPERTIES];
typedef struct _Block1Data Block1Data;

struct _CellRendererTextishPrivate {
	GtkCellEditable* cell;
};

struct _CellEditableDummy {
	GtkEventBox parent_instance;
	CellEditableDummyPrivate * priv;
};

struct _CellEditableDummyClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableDummy* self, GdkEvent* event);
};

struct _CellEditableDummyPrivate {
	gboolean _editing_canceled;
};

struct _CellEditableAccel {
	GtkEventBox parent_instance;
	CellEditableAccelPrivate * priv;
};

struct _CellEditableAccelClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableAccel* self, GdkEvent* event);
};

struct _CellEditableAccelPrivate {
	gboolean _editing_canceled;
	CellRendererTextish* parent;
	gchar* path;
};

struct _CellEditableCombo {
	GtkComboBoxText parent_instance;
	CellEditableComboPrivate * priv;
};

struct _CellEditableComboClass {
	GtkComboBoxTextClass parent_class;
};

struct _CellEditableComboPrivate {
	CellRendererTextish* parent;
	gchar* path;
};

struct _Block1Data {
	int _ref_count_;
	CellEditableCombo* self;
	CellRendererTextish* parent;
	gchar* path;
};

static gint CellRendererTextish_private_offset;
static gpointer cell_renderer_textish_parent_class = NULL;
static gint CellEditableDummy_private_offset;
static gpointer cell_editable_dummy_parent_class = NULL;
static GtkCellEditableIface * cell_editable_dummy_gtk_cell_editable_parent_iface = NULL;
static gint CellEditableAccel_private_offset;
static gpointer cell_editable_accel_parent_class = NULL;
static gboolean cell_editable_accel_background_color_added;
static gboolean cell_editable_accel_background_color_added = FALSE;
static GtkCellEditableIface * cell_editable_accel_gtk_cell_editable_parent_iface = NULL;
static gint CellEditableCombo_private_offset;
static gpointer cell_editable_combo_parent_class = NULL;

static gchar** _vala_array_dup1 (gchar** self,
                          gssize length);
static GtkCellEditable* cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                                           GdkEvent* event,
                                                           GtkWidget* widget,
                                                           const gchar* path,
                                                           const GdkRectangle* background_area,
                                                           const GdkRectangle* cell_area,
                                                           GtkCellRendererState flags);
VALA_EXTERN CellEditableAccel* cell_editable_accel_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget);
VALA_EXTERN CellEditableAccel* cell_editable_accel_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget);
VALA_EXTERN GType cell_editable_accel_get_type (void) G_GNUC_CONST ;
VALA_EXTERN CellEditableCombo* cell_editable_combo_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget,
                                            gchar** items,
                                            gint items_length1);
VALA_EXTERN CellEditableCombo* cell_editable_combo_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget,
                                                  gchar** items,
                                                  gint items_length1);
VALA_EXTERN GType cell_editable_combo_get_type (void) G_GNUC_CONST ;
VALA_EXTERN CellEditableDummy* cell_editable_dummy_new (void);
VALA_EXTERN CellEditableDummy* cell_editable_dummy_construct (GType object_type);
VALA_EXTERN GType cell_editable_dummy_get_type (void) G_GNUC_CONST ;
static void g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                      GValue * return_value,
                                                      guint n_param_values,
                                                      const GValue * param_values,
                                                      gpointer invocation_hint,
                                                      gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                                GValue * return_value,
                                                guint n_param_values,
                                                const GValue * param_values,
                                                gpointer invocation_hint,
                                                gpointer marshal_data);
static void cell_renderer_textish_finalize (GObject * obj);
static GType cell_renderer_textish_get_type_once (void);
VALA_EXTERN void cell_editable_dummy_start_editing (CellEditableDummy* self,
                                        GdkEvent* event);
static void cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                             GdkEvent* event);
VALA_EXTERN gboolean cell_editable_dummy_get_editing_canceled (CellEditableDummy* self);
VALA_EXTERN void cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                               gboolean value);
static void cell_editable_dummy_finalize (GObject * obj);
static GType cell_editable_dummy_get_type_once (void);
static void _vala_cell_editable_dummy_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_dummy_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
VALA_EXTERN void cell_editable_accel_start_editing (CellEditableAccel* self,
                                        GdkEvent* event);
static gint cell_editable_accel_inverse_premultiplied_color (gint color,
                                                      gint alpha);
static void cell_editable_accel_on_editing_done (CellEditableAccel* self);
static void _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                          gpointer self);
static guchar* _vala_array_dup2 (guchar* self,
                          gssize length);
static void cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                             GdkEvent* event);
static gboolean cell_editable_accel_on_key (CellEditableAccel* self,
                                     GdkEventKey* event);
static gboolean _cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                 GdkEventKey* event,
                                                                 gpointer self);
VALA_EXTERN gboolean cell_editable_accel_get_editing_canceled (CellEditableAccel* self);
VALA_EXTERN void cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                               gboolean value);
static void cell_editable_accel_finalize (GObject * obj);
static GType cell_editable_accel_get_type_once (void);
static void _vala_cell_editable_accel_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_accel_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda4_ (Block1Data* _data1_);
static void ___lambda4__gtk_combo_box_changed (GtkComboBox* _sender,
                                        gpointer self);
static void cell_editable_combo_finalize (GObject * obj);
static GType cell_editable_combo_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static inline gpointer _vala_memdup2 (gconstpointer mem,
                        gsize byte_size);

static inline gpointer
cell_renderer_textish_get_instance_private (CellRendererTextish* self)
{
	return G_STRUCT_MEMBER_P (self, CellRendererTextish_private_offset);
}

static GType
cell_renderer_textish_mode_get_type_once (void)
{
	static const GEnumValue values[] = {{CELL_RENDERER_TEXTISH_MODE_Text, "CELL_RENDERER_TEXTISH_MODE_Text", "text"}, {CELL_RENDERER_TEXTISH_MODE_Key, "CELL_RENDERER_TEXTISH_MODE_Key", "key"}, {CELL_RENDERER_TEXTISH_MODE_Popup, "CELL_RENDERER_TEXTISH_MODE_Popup", "popup"}, {CELL_RENDERER_TEXTISH_MODE_Combo, "CELL_RENDERER_TEXTISH_MODE_Combo", "combo"}, {0, NULL, NULL}};
	GType cell_renderer_textish_mode_type_id;
	cell_renderer_textish_mode_type_id = g_enum_register_static ("CellRendererTextishMode", values);
	return cell_renderer_textish_mode_type_id;
}

GType
cell_renderer_textish_mode_get_type (void)
{
	static volatile gsize cell_renderer_textish_mode_type_id__once = 0;
	if (g_once_init_enter (&cell_renderer_textish_mode_type_id__once)) {
		GType cell_renderer_textish_mode_type_id;
		cell_renderer_textish_mode_type_id = cell_renderer_textish_mode_get_type_once ();
		g_once_init_leave (&cell_renderer_textish_mode_type_id__once, cell_renderer_textish_mode_type_id);
	}
	return cell_renderer_textish_mode_type_id__once;
}

CellRendererTextish*
cell_renderer_textish_construct (GType object_type)
{
	CellRendererTextish * self = NULL;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	self->items = NULL;
	self->items_length1 = 0;
	return self;
}

CellRendererTextish*
cell_renderer_textish_new (void)
{
	return cell_renderer_textish_construct (TYPE_CELL_RENDERER_TEXTISH);
}

static gchar**
_vala_array_dup1 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

CellRendererTextish*
cell_renderer_textish_construct_with_items (GType object_type,
                                            gchar** items,
                                            gint items_length1)
{
	CellRendererTextish * self = NULL;
	gchar** _tmp0_;
	gint _tmp0__length1;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	_tmp0_ = (items != NULL) ? _vala_array_dup1 (items, items_length1) : items;
	_tmp0__length1 = items_length1;
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	self->items = _tmp0_;
	self->items_length1 = _tmp0__length1;
	return self;
}

CellRendererTextish*
cell_renderer_textish_new_with_items (gchar** items,
                                      gint items_length1)
{
	return cell_renderer_textish_construct_with_items (TYPE_CELL_RENDERER_TEXTISH, items, items_length1);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static GtkCellEditable*
cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                          GdkEvent* event,
                                          GtkWidget* widget,
                                          const gchar* path,
                                          const GdkRectangle* background_area,
                                          const GdkRectangle* cell_area,
                                          GtkCellRendererState flags)
{
	CellRendererTextish * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GtkCellEditable* _tmp11_;
	GtkCellEditable* result;
	self = (CellRendererTextish*) base;
	g_return_val_if_fail (widget != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (background_area != NULL, NULL);
	g_return_val_if_fail (cell_area != NULL, NULL);
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	g_object_get ((GtkCellRendererText*) self, "editable", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		GtkCellEditable* _tmp2_;
		_tmp2_ = self->priv->cell;
		result = _tmp2_;
		return result;
	}
	switch (self->mode) {
		case CELL_RENDERER_TEXTISH_MODE_Text:
		{
			GdkRectangle _tmp3_;
			GdkRectangle _tmp4_;
			GtkCellEditable* _tmp5_;
			GtkCellEditable* _tmp6_;
			_tmp3_ = *background_area;
			_tmp4_ = *cell_area;
			_tmp5_ = GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->start_editing ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), event, widget, path, &_tmp3_, &_tmp4_, flags);
			_tmp6_ = _g_object_ref0 (_tmp5_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = _tmp6_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Key:
		{
			CellEditableAccel* _tmp7_;
			_tmp7_ = cell_editable_accel_new (self, path, widget);
			g_object_ref_sink (_tmp7_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp7_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Combo:
		{
			gchar** _tmp8_;
			gint _tmp8__length1;
			CellEditableCombo* _tmp9_;
			_tmp8_ = self->items;
			_tmp8__length1 = self->items_length1;
			_tmp9_ = cell_editable_combo_new (self, path, widget, _tmp8_, _tmp8__length1);
			g_object_ref_sink (_tmp9_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp9_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Popup:
		{
			CellEditableDummy* _tmp10_;
			_tmp10_ = cell_editable_dummy_new ();
			g_object_ref_sink (_tmp10_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp10_;
			break;
		}
		default:
		break;
	}
	_tmp11_ = self->priv->cell;
	result = _tmp11_;
	return result;
}

static void
g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                 GValue * return_value,
                                                 guint n_param_values,
                                                 const GValue * param_values,
                                                 gpointer invocation_hint,
                                                 gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_FLAGS_UINT) (gpointer data1, const char* arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__STRING_FLAGS_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_FLAGS_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_flags (param_values + 2), g_value_get_uint (param_values + 3), data2);
}

static void
g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                           GValue * return_value,
                                           guint n_param_values,
                                           const GValue * param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_UINT) (gpointer data1, const char* arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_uint (param_values + 2), data2);
}

static void
cell_renderer_textish_class_init (CellRendererTextishClass * klass,
                                  gpointer klass_data)
{
	cell_renderer_textish_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellRendererTextish_private_offset);
	((GtkCellRendererClass *) klass)->start_editing = (GtkCellEditable* (*) (GtkCellRenderer*, GdkEvent*, GtkWidget*, const gchar*, const GdkRectangle*, const GdkRectangle*, GtkCellRendererState)) cell_renderer_textish_real_start_editing;
	G_OBJECT_CLASS (klass)->finalize = cell_renderer_textish_finalize;
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL] = g_signal_new ("key-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT, G_TYPE_NONE, 3, G_TYPE_STRING, gdk_modifier_type_get_type (), G_TYPE_UINT);
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL] = g_signal_new ("combo-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_UINT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_UINT);
}

static void
cell_renderer_textish_instance_init (CellRendererTextish * self,
                                     gpointer klass)
{
	self->priv = cell_renderer_textish_get_instance_private (self);
}

static void
cell_renderer_textish_finalize (GObject * obj)
{
	CellRendererTextish * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_RENDERER_TEXTISH, CellRendererTextish);
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (self->priv->cell);
	G_OBJECT_CLASS (cell_renderer_textish_parent_class)->finalize (obj);
}

static GType
cell_renderer_textish_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellRendererTextishClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_renderer_textish_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellRendererTextish), 0, (GInstanceInitFunc) cell_renderer_textish_instance_init, NULL };
	GType cell_renderer_textish_type_id;
	cell_renderer_textish_type_id = g_type_register_static (gtk_cell_renderer_text_get_type (), "CellRendererTextish", &g_define_type_info, 0);
	CellRendererTextish_private_offset = g_type_add_instance_private (cell_renderer_textish_type_id, sizeof (CellRendererTextishPrivate));
	return cell_renderer_textish_type_id;
}

GType
cell_renderer_textish_get_type (void)
{
	static volatile gsize cell_renderer_textish_type_id__once = 0;
	if (g_once_init_enter (&cell_renderer_textish_type_id__once)) {
		GType cell_renderer_textish_type_id;
		cell_renderer_textish_type_id = cell_renderer_textish_get_type_once ();
		g_once_init_leave (&cell_renderer_textish_type_id__once, cell_renderer_textish_type_id);
	}
	return cell_renderer_textish_type_id__once;
}

static inline gpointer
cell_editable_dummy_get_instance_private (CellEditableDummy* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableDummy_private_offset);
}

static void
cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                        GdkEvent* event)
{
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
}

void
cell_editable_dummy_start_editing (CellEditableDummy* self,
                                   GdkEvent* event)
{
	CellEditableDummyClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_DUMMY_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

CellEditableDummy*
cell_editable_dummy_construct (GType object_type)
{
	CellEditableDummy * self = NULL;
	self = (CellEditableDummy*) g_object_new (object_type, NULL);
	return self;
}

CellEditableDummy*
cell_editable_dummy_new (void)
{
	return cell_editable_dummy_construct (TYPE_CELL_EDITABLE_DUMMY);
}

gboolean
cell_editable_dummy_get_editing_canceled (CellEditableDummy* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_editing_canceled;
	return result;
}

void
cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = cell_editable_dummy_get_editing_canceled (self);
	if (old_value != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY]);
	}
}

static void
cell_editable_dummy_class_init (CellEditableDummyClass * klass,
                                gpointer klass_data)
{
	cell_editable_dummy_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableDummy_private_offset);
	((CellEditableDummyClass *) klass)->start_editing = (void (*) (CellEditableDummy*, GdkEvent*)) cell_editable_dummy_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_dummy_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_dummy_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_dummy_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
cell_editable_dummy_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_dummy_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_dummy_start_editing;
}

static void
cell_editable_dummy_instance_init (CellEditableDummy * self,
                                   gpointer klass)
{
	self->priv = cell_editable_dummy_get_instance_private (self);
}

static void
cell_editable_dummy_finalize (GObject * obj)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	G_OBJECT_CLASS (cell_editable_dummy_parent_class)->finalize (obj);
}

static GType
cell_editable_dummy_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableDummyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_dummy_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableDummy), 0, (GInstanceInitFunc) cell_editable_dummy_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_dummy_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_dummy_type_id;
	cell_editable_dummy_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableDummy", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_dummy_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableDummy_private_offset = g_type_add_instance_private (cell_editable_dummy_type_id, sizeof (CellEditableDummyPrivate));
	return cell_editable_dummy_type_id;
}

GType
cell_editable_dummy_get_type (void)
{
	static volatile gsize cell_editable_dummy_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_dummy_type_id__once)) {
		GType cell_editable_dummy_type_id;
		cell_editable_dummy_type_id = cell_editable_dummy_get_type_once ();
		g_once_init_leave (&cell_editable_dummy_type_id__once, cell_editable_dummy_type_id);
	}
	return cell_editable_dummy_type_id__once;
}

static void
_vala_cell_editable_dummy_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_dummy_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_cell_editable_dummy_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		cell_editable_dummy_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
cell_editable_accel_get_instance_private (CellEditableAccel* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableAccel_private_offset);
}

static gint
cell_editable_accel_inverse_premultiplied_color (gint color,
                                                 gint alpha)
{
	gint result;
	if (alpha == 0) {
		result = 0;
		return result;
	}
	result = (((255 * color) + alpha) - 1) / alpha;
	return result;
}

static void
_cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                     gpointer self)
{
	cell_editable_accel_on_editing_done ((CellEditableAccel*) self);
}

static guchar*
_vala_array_dup2 (guchar* self,
                  gssize length)
{
	if (length > 0) {
		return _vala_memdup2 (self, length * sizeof (guchar));
	}
	return NULL;
}

CellEditableAccel*
cell_editable_accel_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget)
{
	CellEditableAccel * self = NULL;
	CellRendererTextish* _tmp0_;
	gchar* _tmp1_;
	GtkLabel* label = NULL;
	GtkLabel* _tmp2_;
	GtkLabel* _tmp3_;
	GtkLabel* _tmp4_;
	GtkLabel* _tmp5_;
	GtkStyleContext* _tmp46_;
	GtkLabel* _tmp47_;
	GtkStyleContext* _tmp48_;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	self = (CellEditableAccel*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp0_;
	_tmp1_ = g_strdup (path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp1_;
	g_signal_connect_object ((GtkCellEditable*) self, "editing-done", (GCallback) _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done, self, 0);
	_tmp2_ = (GtkLabel*) gtk_label_new (_ ("Key combination..."));
	g_object_ref_sink (_tmp2_);
	label = _tmp2_;
	_tmp3_ = label;
	gtk_widget_set_halign ((GtkWidget*) _tmp3_, GTK_ALIGN_START);
	_tmp4_ = label;
	gtk_widget_set_valign ((GtkWidget*) _tmp4_, GTK_ALIGN_CENTER);
	_tmp5_ = label;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp5_);
	if (!cell_editable_accel_background_color_added) {
		GdkScreen* screen = NULL;
		GdkScreen* _tmp6_;
		GdkScreen* _tmp7_;
		GtkCssProvider* css_provider = NULL;
		GtkCssProvider* _tmp8_;
		GtkStyleContext* styleContext = NULL;
		GtkStyleContext* _tmp9_;
		GtkStyleContext* _tmp10_;
		GtkStyleContext* _tmp11_;
		GtkStyleContext* _tmp12_;
		cairo_surface_t* surface = NULL;
		cairo_surface_t* _tmp13_;
		cairo_t* context = NULL;
		cairo_surface_t* _tmp14_;
		cairo_t* _tmp15_;
		GtkStyleContext* _tmp16_;
		cairo_t* _tmp17_;
		cairo_t* _tmp18_;
		cairo_surface_t* _tmp19_;
		GtkStyleContext* _tmp20_;
		guchar* data = NULL;
		cairo_surface_t* _tmp21_;
		guchar* _tmp22_;
		guchar* _tmp23_;
		gint _tmp23__length1;
		gint data_length1;
		gint _data_size_;
		guchar* _tmp24_;
		gint _tmp24__length1;
		gint a = 0;
		guchar* _tmp26_;
		gint _tmp26__length1;
		guchar _tmp27_;
		gint r = 0;
		guchar* _tmp28_;
		gint _tmp28__length1;
		guchar _tmp29_;
		gint g = 0;
		guchar* _tmp30_;
		gint _tmp30__length1;
		guchar _tmp31_;
		gint b = 0;
		guchar* _tmp32_;
		gint _tmp32__length1;
		guchar _tmp33_;
		GdkRGBA rgba = {0};
		GdkRGBA _tmp34_ = {0};
		gchar* css = NULL;
		gchar* _tmp35_;
		gchar* _tmp36_;
		gchar* _tmp37_;
		gchar* _tmp38_;
		gchar* _tmp39_;
		gchar* _tmp40_;
		_tmp6_ = gtk_widget_get_screen ((GtkWidget*) self);
		_tmp7_ = _g_object_ref0 (_tmp6_);
		screen = _tmp7_;
		_tmp8_ = gtk_css_provider_new ();
		css_provider = _tmp8_;
		_tmp9_ = gtk_widget_get_style_context (widget);
		_tmp10_ = _g_object_ref0 (_tmp9_);
		styleContext = _tmp10_;
		_tmp11_ = styleContext;
		gtk_style_context_save (_tmp11_);
		_tmp12_ = styleContext;
		gtk_style_context_set_state (_tmp12_, GTK_STATE_FLAG_SELECTED);
		_tmp13_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 1, 1);
		surface = _tmp13_;
		_tmp14_ = surface;
		_tmp15_ = cairo_create (_tmp14_);
		context = _tmp15_;
		_tmp16_ = styleContext;
		_tmp17_ = context;
		gtk_render_background (_tmp16_, _tmp17_, (gdouble) -50, (gdouble) -50, (gdouble) 100, (gdouble) 100);
		_tmp18_ = context;
		cairo_fill (_tmp18_);
		_tmp19_ = surface;
		cairo_surface_flush (_tmp19_);
		_tmp20_ = styleContext;
		gtk_style_context_restore (_tmp20_);
		_tmp21_ = surface;
		_tmp22_ = cairo_image_surface_get_data (_tmp21_);
		_tmp23_ = (_tmp22_ != NULL) ? _vala_array_dup2 (_tmp22_, -1) : _tmp22_;
		_tmp23__length1 = -1;
		data = _tmp23_;
		data_length1 = _tmp23__length1;
		_data_size_ = data_length1;
		_tmp24_ = data;
		_tmp24__length1 = data_length1;
		if (_tmp24_ == NULL) {
			guchar* _tmp25_;
			_tmp25_ = g_new0 (guchar, 4);
			_tmp25_[0] = (guchar) 0;
			_tmp25_[1] = (guchar) 0;
			_tmp25_[2] = (guchar) 0;
			_tmp25_[3] = (guchar) 0;
			data = (g_free (data), NULL);
			data = _tmp25_;
			data_length1 = 4;
			_data_size_ = data_length1;
		}
		_tmp26_ = data;
		_tmp26__length1 = data_length1;
		_tmp27_ = _tmp26_[3];
		a = (gint) _tmp27_;
		_tmp28_ = data;
		_tmp28__length1 = data_length1;
		_tmp29_ = _tmp28_[2];
		r = (gint) _tmp29_;
		_tmp30_ = data;
		_tmp30__length1 = data_length1;
		_tmp31_ = _tmp30_[1];
		g = (gint) _tmp31_;
		_tmp32_ = data;
		_tmp32__length1 = data_length1;
		_tmp33_ = _tmp32_[0];
		b = (gint) _tmp33_;
		memset (&_tmp34_, 0, sizeof (GdkRGBA));
		_tmp34_.alpha = (gdouble) (a / 255.f);
		_tmp34_.red = (gdouble) (cell_editable_accel_inverse_premultiplied_color (r, a) / 255.f);
		_tmp34_.green = (gdouble) (cell_editable_accel_inverse_premultiplied_color (g, a) / 255.f);
		_tmp34_.blue = (gdouble) (cell_editable_accel_inverse_premultiplied_color (b, a) / 255.f);
		rgba = _tmp34_;
		_tmp35_ = gdk_rgba_to_string (&rgba);
		_tmp36_ = _tmp35_;
		_tmp37_ = g_strconcat (".cell_editable_accel_bg { background-color: ", _tmp36_, NULL);
		_tmp38_ = _tmp37_;
		_tmp39_ = g_strconcat (_tmp38_, ";}", NULL);
		_tmp40_ = _tmp39_;
		_g_free0 (_tmp38_);
		_g_free0 (_tmp36_);
		css = _tmp40_;
		{
			GtkCssProvider* _tmp41_;
			const gchar* _tmp42_;
			GdkScreen* _tmp43_;
			GtkCssProvider* _tmp44_;
			_tmp41_ = css_provider;
			_tmp42_ = css;
			gtk_css_provider_load_from_data (_tmp41_, _tmp42_, (gssize) -1, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
			_tmp43_ = screen;
			_tmp44_ = css_provider;
			gtk_style_context_add_provider_for_screen (_tmp43_, (GtkStyleProvider*) _tmp44_, (guint) GTK_STYLE_PROVIDER_PRIORITY_USER);
		}
		goto __finally0;
		__catch0_g_error:
		{
			GError* e = NULL;
			const gchar* _tmp45_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp45_ = e->message;
			g_error ("cellrenderertextish.vala:109: Cannot load CSS stylesheet: %s", _tmp45_);
			_g_error_free0 (e);
		}
		__finally0:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (css);
			data = (g_free (data), NULL);
			_cairo_destroy0 (context);
			_cairo_surface_destroy0 (surface);
			_g_object_unref0 (styleContext);
			_g_object_unref0 (css_provider);
			_g_object_unref0 (screen);
			_g_object_unref0 (label);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		cell_editable_accel_background_color_added = TRUE;
		_g_free0 (css);
		data = (g_free (data), NULL);
		_cairo_destroy0 (context);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (styleContext);
		_g_object_unref0 (css_provider);
		_g_object_unref0 (screen);
	}
	_tmp46_ = gtk_widget_get_style_context ((GtkWidget*) self);
	gtk_style_context_add_class (_tmp46_, "cell_editable_accel_bg");
	_tmp47_ = label;
	_tmp48_ = gtk_widget_get_style_context ((GtkWidget*) _tmp47_);
	gtk_style_context_add_class (_tmp48_, "cell_editable_accel_bg");
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (label);
	return self;
}

CellEditableAccel*
cell_editable_accel_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget)
{
	return cell_editable_accel_construct (TYPE_CELL_EDITABLE_ACCEL, parent, path, widget);
}

static gboolean
_cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                        GdkEventKey* event,
                                                        gpointer self)
{
	gboolean result;
	result = cell_editable_accel_on_key ((CellEditableAccel*) self, event);
	return result;
}

static void
cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                        GdkEvent* event)
{
	GdkSeat* seat = NULL;
	GdkDisplay* _tmp0_;
	GdkSeat* _tmp1_;
	GdkSeat* _tmp2_;
	GdkWindow* _tmp3_;
	gtk_grab_add ((GtkWidget*) self);
	_tmp0_ = gdk_display_get_default ();
	_tmp1_ = gdk_display_get_default_seat (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	seat = _tmp2_;
	_tmp3_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_seat_grab (seat, _tmp3_, GDK_SEAT_CAPABILITY_KEYBOARD, FALSE, NULL, event, NULL, NULL);
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) _cell_editable_accel_on_key_gtk_widget_key_press_event, self, 0);
	_g_object_unref0 (seat);
}

void
cell_editable_accel_start_editing (CellEditableAccel* self,
                                   GdkEvent* event)
{
	CellEditableAccelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_ACCEL_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

static gboolean
cell_editable_accel_on_key (CellEditableAccel* self,
                            GdkEventKey* event)
{
	GdkModifierType mods = 0U;
	CellRendererTextish* _tmp0_;
	const gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	if (event->is_modifier != ((guint) 0)) {
		result = TRUE;
		return result;
	}
	switch (event->keyval) {
		case GDK_KEY_Super_L:
		case GDK_KEY_Super_R:
		case GDK_KEY_Hyper_L:
		case GDK_KEY_Hyper_R:
		{
			result = TRUE;
			return result;
		}
		default:
		break;
	}
	mods = event->state & gtk_accelerator_get_default_mod_mask ();
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
	_tmp0_ = self->priv->parent;
	_tmp1_ = self->priv->path;
	g_signal_emit (_tmp0_, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL], 0, _tmp1_, mods, (guint) event->hardware_keycode);
	result = TRUE;
	return result;
}

static void
cell_editable_accel_on_editing_done (CellEditableAccel* self)
{
	GdkDisplay* _tmp0_;
	GdkSeat* _tmp1_;
	g_return_if_fail (self != NULL);
	gtk_grab_remove ((GtkWidget*) self);
	_tmp0_ = gdk_display_get_default ();
	_tmp1_ = gdk_display_get_default_seat (_tmp0_);
	gdk_seat_ungrab (_tmp1_);
}

gboolean
cell_editable_accel_get_editing_canceled (CellEditableAccel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_editing_canceled;
	return result;
}

void
cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = cell_editable_accel_get_editing_canceled (self);
	if (old_value != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY]);
	}
}

static void
cell_editable_accel_class_init (CellEditableAccelClass * klass,
                                gpointer klass_data)
{
	cell_editable_accel_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableAccel_private_offset);
	((CellEditableAccelClass *) klass)->start_editing = (void (*) (CellEditableAccel*, GdkEvent*)) cell_editable_accel_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_accel_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_accel_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_accel_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
cell_editable_accel_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_accel_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_accel_start_editing;
}

static void
cell_editable_accel_instance_init (CellEditableAccel * self,
                                   gpointer klass)
{
	self->priv = cell_editable_accel_get_instance_private (self);
}

static void
cell_editable_accel_finalize (GObject * obj)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_accel_parent_class)->finalize (obj);
}

static GType
cell_editable_accel_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableAccelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_accel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableAccel), 0, (GInstanceInitFunc) cell_editable_accel_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_accel_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_accel_type_id;
	cell_editable_accel_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableAccel", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_accel_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableAccel_private_offset = g_type_add_instance_private (cell_editable_accel_type_id, sizeof (CellEditableAccelPrivate));
	return cell_editable_accel_type_id;
}

GType
cell_editable_accel_get_type (void)
{
	static volatile gsize cell_editable_accel_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_accel_type_id__once)) {
		GType cell_editable_accel_type_id;
		cell_editable_accel_type_id = cell_editable_accel_get_type_once ();
		g_once_init_leave (&cell_editable_accel_type_id__once, cell_editable_accel_type_id);
	}
	return cell_editable_accel_type_id__once;
}

static void
_vala_cell_editable_accel_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_accel_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_cell_editable_accel_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		cell_editable_accel_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
cell_editable_combo_get_instance_private (CellEditableCombo* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableCombo_private_offset);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		CellEditableCombo* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->parent);
		_g_free0 (_data1_->path);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
__lambda4_ (Block1Data* _data1_)
{
	CellEditableCombo* self;
	gint _tmp0_;
	gint _tmp1_;
	self = _data1_->self;
	_tmp0_ = gtk_combo_box_get_active ((GtkComboBox*) self);
	_tmp1_ = _tmp0_;
	g_signal_emit (_data1_->parent, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL], 0, _data1_->path, (guint) _tmp1_);
}

static void
___lambda4__gtk_combo_box_changed (GtkComboBox* _sender,
                                   gpointer self)
{
	__lambda4_ (self);
}

CellEditableCombo*
cell_editable_combo_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget,
                               gchar** items,
                               gint items_length1)
{
	CellEditableCombo * self = NULL;
	Block1Data* _data1_;
	CellRendererTextish* _tmp0_;
	gchar* _tmp1_;
	CellRendererTextish* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = _g_object_ref0 (parent);
	_g_object_unref0 (_data1_->parent);
	_data1_->parent = _tmp0_;
	_tmp1_ = g_strdup (path);
	_g_free0 (_data1_->path);
	_data1_->path = _tmp1_;
	self = (CellEditableCombo*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp2_ = _g_object_ref0 (_data1_->parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp2_;
	_tmp3_ = g_strdup (_data1_->path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp3_;
	{
		gchar** item_collection = NULL;
		gint item_collection_length1 = 0;
		gint _item_collection_size_ = 0;
		gint item_it = 0;
		item_collection = items;
		item_collection_length1 = items_length1;
		for (item_it = 0; item_it < item_collection_length1; item_it = item_it + 1) {
			gchar* _tmp4_;
			gchar* item = NULL;
			_tmp4_ = g_strdup (item_collection[item_it]);
			item = _tmp4_;
			{
				const gchar* _tmp5_;
				_tmp5_ = item;
				gtk_combo_box_text_append_text ((GtkComboBoxText*) self, _ (_tmp5_));
				_g_free0 (item);
			}
		}
	}
	g_signal_connect_data ((GtkComboBox*) self, "changed", (GCallback) ___lambda4__gtk_combo_box_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}

CellEditableCombo*
cell_editable_combo_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget,
                         gchar** items,
                         gint items_length1)
{
	return cell_editable_combo_construct (TYPE_CELL_EDITABLE_COMBO, parent, path, widget, items, items_length1);
}

static void
cell_editable_combo_class_init (CellEditableComboClass * klass,
                                gpointer klass_data)
{
	cell_editable_combo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableCombo_private_offset);
	G_OBJECT_CLASS (klass)->finalize = cell_editable_combo_finalize;
}

static void
cell_editable_combo_instance_init (CellEditableCombo * self,
                                   gpointer klass)
{
	self->priv = cell_editable_combo_get_instance_private (self);
}

static void
cell_editable_combo_finalize (GObject * obj)
{
	CellEditableCombo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_COMBO, CellEditableCombo);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_combo_parent_class)->finalize (obj);
}

static GType
cell_editable_combo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableComboClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_combo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableCombo), 0, (GInstanceInitFunc) cell_editable_combo_instance_init, NULL };
	GType cell_editable_combo_type_id;
	cell_editable_combo_type_id = g_type_register_static (gtk_combo_box_text_get_type (), "CellEditableCombo", &g_define_type_info, 0);
	CellEditableCombo_private_offset = g_type_add_instance_private (cell_editable_combo_type_id, sizeof (CellEditableComboPrivate));
	return cell_editable_combo_type_id;
}

GType
cell_editable_combo_get_type (void)
{
	static volatile gsize cell_editable_combo_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_combo_type_id__once)) {
		GType cell_editable_combo_type_id;
		cell_editable_combo_type_id = cell_editable_combo_get_type_once ();
		g_once_init_leave (&cell_editable_combo_type_id__once, cell_editable_combo_type_id);
	}
	return cell_editable_combo_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static inline gpointer
_vala_memdup2 (gconstpointer mem,
               gsize byte_size)
{
	gpointer new_mem;
	if (mem && byte_size != 0) {
		new_mem = g_malloc (byte_size);
		memcpy (new_mem, mem, byte_size);
	} else {
		new_mem = NULL;
	}
	return new_mem;
}

